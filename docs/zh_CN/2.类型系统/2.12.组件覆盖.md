## 组件覆盖

组件结构可使用`override`关键字声明覆盖组件，用于构造在一个基组件上的行为变体，其语法如下：

```ecs
override OverrideComp: OriginComp { body }
```

`{body}`是覆盖组件的类型体，**在此体中不可声明任何新的在此组件之外可见的成员**，它只能声明在其覆盖的组件中已经声明的成员的重写，这不包含被覆盖成员所包含的组件列表。

在对组件进行覆盖时，始终不会改变组件的包含结构，即组件的衍生变体始终保留其覆盖组件的包含结构。

覆盖组件用于创建组件变体，用于重写其覆盖的组件中的可衍生成员，衍生成员可通过`super`关键字来访问被覆盖的成员，如下例所示：

```ecs
comp Comp1{
  fun foo(){
    println("hello world")
  }
}

override Comp2: Comp1{
  override fun foo(){
    super.foo()
    println("hello EnComping")
  }
}

new Comp1().foo() // hello world
new Comp2().foo() // hello world
                     hello EnComping
```

同样的，属性也是可以被覆盖的，如下例所示：

```ecs
comp Comp1{
  var a: Int = 1
  val b: Int = 2
}

override Comp2: Comp1{
  override var a: Int{
    default = 0
    
    get() = default++
    set(value) = default = value
  }
  
  override val b: Int{
    get() = super.b + 1
  }
}

val c = new Comp2()
c.a // 0
c.a // 1
c.a // 2

new Comp2().a // 3
```

### 可衍生成员

可衍生成员是在组件当中可以被覆盖的函数或者属性，具有有如下特征：

- 是成员函数或者成员属性
- 不是初始化函数
- 非`private`
- 成员变量非`const`
- 非`final`

需要特别强调的是`final`修饰符，该修饰符与属性值的可变性无关，它只用于描述此函数或者属性是一个不可衍生的成员，使得此成员无法被覆盖。

就像下文所示，一个`final var`仍然是可变量，只是它不能被用于组件覆盖的衍生行为。

```ecs
final var a = 10

a = 100
println(a) // 100
```

当`final`修饰符被用于组件上时，这整个组件都无法被用于覆盖变体组件，但并不会影响组件的包含。

如下代码是非法的：

```ecs
final comp Comp{...}

override OverComp: Comp{...}
```

### 组件动态替换

对象中的组件在运行时是可以被动态替换的，但仅限于使用在这个衍生结构当中的组件，即用于替换的组件必须是从此组件中衍生的或者是此组件的衍生前体。

替换组件的语句格式如下：

```ecs
object:Component <- OverComponent[(args)]
```

替换组件时，如果组件内的初始化函数都需要参数，则替换组件时用于覆盖的组件必须调用其中的初始化函数。

对对象替换它的组件后，对象在此组件上的行为会立即变更为用于替换的变体提供的行为。

```ecs
comp Comp(val id: Int){
  fun foo(){
    println("hello world")
  }
}

override Comp2(id: Int): Comp(id){
  override fun foo(){
    println("hello EnComping")
  }
}

val obj = new Comp(1)
obj.foo()       // hello world
println(obj.id) // 1
obj:Comp <- Comp2(10)
obj.foo()       // hello EnComping
println(obj.id) // 10
```

在组件的包含声明当中，也可以使用`final`修饰符标记组件列表中的组件来使此组件不可被替换：

```ecs
comp Comp: Comp1, final Comp2, final Comp3 as c3{...}

override Over1: Comp1{...}
override Over2: Comp2{...}
override Over3: Comp3{...}

val obj = new Comp()
obj:Comp1 <- Over1   //合法
obj:Comp2 <- Over2   //非法
obj:c3 <- Over3      //非法
```
