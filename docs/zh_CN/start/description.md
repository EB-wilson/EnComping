## EnComping 语言介绍

EnCompin是一种完全组合式编程语言（Combination Programing，CP），其旨在提供一种基于组合的元编程模式，使开发者可以直接以**组件-对象**的模式进行编程。

该语言设计之初即为了将`ECS`架构中的宝贵思想引入到编程语言当中，因此，EnComping是面向对象的编程语言，但它并非扩展式（Extend）的面向对象，而是组合式面向对象，与传统的面向对象语言不同，EnComping当中没有**继承**等概念，组件的**包含**被用于代替其需要实现的功能。

EnComping被设计为可在jvm上工作的编程语言，并且后续会有计划的实现它在native平台，.net和到js等平台的编译运行支持。

### 基本语法

EnComping的程序文件后缀名称为`.ecs`或者`.ecp`，二者有略微的差异，在之后会有阐述。EnComping可直接简称为ECP，下文亦采用ECP代指EnComping

以下是使用ECP编写的一段简单的HelloWorld程序：

```ecs
@EntryPoint
fun main(args: String[]){
  println("Hello World!")
}

```

其中，`@EntryPoint`是用于标记程序的入口点的一个简单注解，`println`函数的作用即向系统标准输出流打印一段文本并换行，将上文保存到HelloWorld.ecs，并在此目录下打开终端，执行如下命令：

```sh
ecp HelloWorld.ecs
```

即可看到在终端打印了一段文本：`Hello World!`

如同许多现代化编程语言一样，ECP也抛弃了句尾分号，可选输入，但通常不推荐在语义清晰的上下文中，仍在语句末尾附加句尾分号。

### 变量

在ECP中，变量有多种修饰符，顶级变量的修饰符构成相对简单，此处以.ecs中声明的顶级变量为例进行解释。

变量声明的一般语法形式：

```ecs
var exampleVar: Type = value
```

上述语句声明了一个名为`exampleVar`的，类型为`Type`的可变变量。从可读写划分，变量分为可写和只读，它们的区别在于前缀上采用的关键字是**var**还是**val**，若为val，则变量在值初始化后就不允许再更改其值了。

除此之外，val变量可附加const修饰符表示常量，此时其必须为简单的基础数据类型，后文会给出基础数据类型列表，常量会有不同的行为，比如它会直接内联在调用处等。

### 组合类型系统

在ECP中，所有的概念和功能都被抽象为了**组件**（Component）和**对象**(Object)，组件共有的基础类型即被称为**组件原型**，而组件则被用于为对象提供所有功能，同时组件原型即为访问对象功能的协议，即表观类型。

对象则是**组合类型**的实例，而组合类型，又是包含了一系列组件原型的集合，即：**对象包含了一系列组件，而组合类型是此对象的类型依据，它告知了对象应当包含哪些组件，那些组件的功能又是在组件原型当中被定义的**。

在ECP当中，类型大致可分为**基础类型**，**组件原型**和**组合类型**，其中组件类型与组合类型承担了绝大部分的功能，它们都可以被用于变量和参数等所需的表观类型，在形式上：

- 一个组件原型的声明形式如下：

```ecp
comp ExampleComp{
  ...
}
```

- 组合类型声明形式则如下:

```ecp
combine ExampleType: ExampleComp{
  ...
}
```

关于它们的详细内容会在章节 *组件与组合* 当中详细论述。

> 需要注意的是，在上述的两个结构中，两个完全相同的子声明可能实际功能会完全不同，这在之后的章节中会详细阐述。

而基础类型，包括数字，字符串等数据类型事实上也被描述为了**组合类型**，下表列出了ECP当中的所有基础数据类型：

| 类型 | 释义 | 示例 |
| :------: | -------- | -------- |
| Unit | 空类型占位 | Unit |
| Byte | 8位整数 | 123 |
| Short | 16位整数 | 12345 |
| Int | 32位整数 | 123456789 |
| Long | 64位整数 | 123456789L |
| Float | 32位浮点数 | 3.1415926F |
| Double | 64位浮点数 | 2.7182818 |
| Boolean | 布尔值 | true |
| Char | 单字符 | 'C' |
| String | 字符串 | "HelloWorld" |

在基础数据类型之上，还有一类**结构类型**，它包括：

- 数组 - **Array**
*类型声明示例*：`String[]`

- 元组 - **Tuple**
*类型声明示例*：`(String, Int)`

- 区间 - **Interval**
*类型声明示例*：`Comparable<Int>..Comparable<Float>`

- 构造 - **Struct**
*类型声明示例*: `{name: String, age: Int}`

- 函数 - **Function**
*类型声明示例*：`(String) -> Unit`

上述结构类型各自的功能都较为复杂，关于它们的使用会在文档中对应的章节做详尽的描述。

### 空值严格

ECP是空值严格的，类型默认非空，例如在变量：

```
var name: String = "Alice"
```

上赋值null，程序会立即终止并抛出异常告知这是不允许的操作，并且通常情况下，在编译时可被分析出来的可能赋值为null处也会发出错误并终止编译，若您需要令变量为可空类型，那么只需要在类型后面加上一个问号，就像这样：

```
var name: String? = null
```

这样可空变量就可以被赋为空值，但它将不可直接为非空变量赋值，因为它们会被认为类型是不同的，你可以采用可空变量的一系列为空值检查设计的**Optional**操作来完成可空与非空转换，更多信息请参阅章节*可空类型*

### 关于.ecs与.ecp的区别

ecs，是EnComping Script的缩写，而ecp为EnComping Program的缩写，它们含义不尽相同。

在.ecs文件中，可以直接在最顶层编写任意声明，包括变量，函数等，它们不需要被包括在任何其他程序块当中，并且可以直接被导入并访问，例如您可以在ecs文件中进行如下声明：

```ecs
var a = 1
var b = 0

@EntryPoint
fun main(){
  println("Hello World!")
}
```

而.ecp文件当中顶层必须是有且只有一个程序块，它可以是组件原型声明，可以是组合类型声明，以及一些其他顶级程序块的声明，所有的程序内容都必须被包括在这个顶级程序块中，并且此程序块的名称必须和文件名相同。如果您需要使用.ecp文件中的函数作为入口点，您可以编写如下程序：

```ecp
@EntryPoint
comp HelloWorld{
  init{
    println("Hello World!")
  }
}
```

如程序所述，如果您将`@EntryPoint`注解用于组件原型或者组合类型上，那么程序启动时即会实例化该入口，并将参数传递给其初始化函数，此处的初始化函数不携带参数，即不接收命令行参数。

将该程序保存为HelloWorld.ecp并运行，将得到和上文相同的打印结果。