## 数组

**数组（Array）** 是一块**容量确定**的可以有序存放一系列特定类型的对象的容器。

数组的类型为被`[]`包裹的类型，形如`[ElementType]`，可多层数组类型嵌套。特别的，数组类型还可以附加长度信息，形如：`[ElementType:length]`，此种形式被成为`定长数组类型`。

```ecs
val arr1: [Int]
val arr2: [String?]
val arr3: [String*10]
```

通常可以通过表达式`{elements}`获取一个数组的实例，特别的是，对于元素类型可为空的**定长数组**，可以使用单下划线占位`{_}`来使用空值填充整个数组：

```ecs
val arr4 = {"str1", "str2", "str3"}
val arr5: [Int] = {1, 2, 3, 4, 5}
val arr6: [Boolean] = {true, false, true}
val arr7: [Any?*3] = {_}
```

但有时候声明处会缺失明确的类型信息，或者数组并非定长数组类型，亦或者需要通过一个初始值函数来生成数组元素，则应采用`new [ElementType:length]{value builder}`的方式来实例化数组，元素类型在已给定时是可选的，而当类型的长度信息明确时，可省略长度限定，此时该语句有数种变体：

```ecs
val arr8 = new [String*3]{ "unset" }
val arr9: [Boolean] = new [3]{ false }
val arr10: [Int?] = new [?100]{ i -> i }
val arr11: [Int*10] = new []{ 0 }
```

特别注意，在上述三个语句中出现的实例化语句右侧的`{...}`块含义与前者字面量的含义完全不同，在此处该块表示了一个匿名函数用于生成数组元素默认值，而非用于字面设定数组元素。

初始值函数当中会有一组与数组的嵌套维数相同个数的`Int`类型的参数，用于确定函数正在填充的数组索引，但是也可以不接收参数，直接使用无参数的Lambda块，即将此块的返回值填充到数组的每一个位置。

### 读写数组

ECP中数组的下标从`0`开始，即索引`0`对应的是数组的**第一个**元素。要访问和设置数组中的元素，可以使用符号`[index]`索引数组的下标：

```ecs
val arr = {1, 2, 3, 4, 5}

println(arr.length)      // 输出 5

println(arr[0])          // 输出 1
println(arr[2])          // 输出 3
arr[2] = 10              // 将索引为 2 的元素修改为 10
println(arr)             // 输出 [1, 2, 10, 4, 5]
``` 

或者使用与此符号相应的成员函数，尽管这并不被建议使用：

```ecs
val arr = {1, 2, 3, 4, 5}

println(arr.length)      // 输出 5

println(arr.get(0))      // 输出 1
println(arr.get(2))      // 输出 3
arr.set(2, 10)           // 将索引为 2 的元素修改为 10
println(arr)             // 输出 [1, 2, 10, 4, 5]
```

需要注意的是数组的下标范围，**数组下标不可小于0或大于等于其容量**，可以通过对数组访问其只读成员`length`来获取数组的长度，如果越界情况在运行期可以被检查出来，则在编译期将会报错。特别地，对于数组，如果在编译期无法判断越界情况，且在运行期实际输入的索引不属于此范围，则程序会抛出异常`IndexOutOfBoundsException`。

### 多维数组

多维数组，即数组元素也是数组的多层嵌套的数组声明，例如：

```ecs
val a: [String] = new [10]{ "($it)" }
val b: [[String]] = new [[10]*10]{ x, y -> "($x, $y)" }
val c: [[[String]]] = new [[[?10]?*10]?*10]?{ x, y, z -> "($x, $y, $z)" }

println(a[3])    // 输出 (3)
println(b[3][4]) // 输出 (3, 4)
println(b[5])    // 输出 [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)]
println(c[2][3]) // 输出 [(2, 3, 0), (2, 3, 1), (2, 3, 2), (2, 3, 3), (2, 3, 4), (2, 3, 5), (2, 3, 6), (2, 3, 7), (2, 3, 8), (2, 3, 9)]
```

上述`a` `b` `c`依次是一维，二维和三维数组，多维数组的初始值函数参数会依次接收在多维数组中各维度上的索引。其中变量`c`是一个全维度类型可空的数组。

特别的，多维数组也可以采用类似于java的形式进行实例化，区别在于当类型信息缺省时，类型信息会包含可空信息，同时尾随的块为初始值函数而非数组字面值，而且当长度信息确定时，长度也可以缺省：

```ecs
val arr1: [[String]] = new String[10][10]{ "none" }
val arr2: [[[Any?*10]*10]*10] = new String[][][]
val arr3: [[Any]?] = new String[10]

val arr4 = new String[10][10]{ x, y -> "($x, $y)"}
val arr5 = new String[?10][?10][?10]
```
