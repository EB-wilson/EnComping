## 复刻函数

**复刻函数（Fork Function）** 是在组件中从其包含的组件内拉取函数的变基拷贝的方式，使用`fork`关键字进行声明，语法如下所示：

```ecs
[modifiers] fork fun <function name>[<Type Args>]([args])[{body}]
```

复刻函数的作用在于将来自其包含的组件中的同签名函数完整的拷贝至本组件中，并将`this`指针重定向到复刻函数定义的组件上：

```ecs
comp Comp1{
  val str = "none"
  
  fun foo(){
    println(str)
  }
}

comp Comp2: Comp1{
  val str = "hello world"
  
  fork fun foo()
}

new Comp1().foo() // 输出：none
new Comp2().foo() // 输出：hello world
```

### 复刻函数体

复刻函数默认情况下会直接创建原函数的变基拷贝，但有时候会需要对复刻函数进行更改，如在调用前或者之后附加一些行为，此时则使用关键字`base`来在复刻函数体中标记变基后的函数拷贝：

```ecs
comp Comp3: Comp1{
  val str = "hello world"
  
  fork fun foo(){
    println("before foo()")
    base.foo()
    println("after foo()")
  }
}

new Comp3().foo() // before foo() 
                  // hello world
                  // after foo()
```

如果在组件的包含结构中存在多个同签名的函数时，此时复刻函数会检查最近的层次中的同签名函数，当搜索到的函数有多个时则此复刻函数必须声明函数体，并明确复刻的目标函数，而如果可以确定唯一的目标函数，则可以如前文所示的那样省略函数体。

在复刻函数的基函数待定时，需要明确选择来源组件，选择组件的语法为`base@Comp`

例如如下代码：

```ecs
comp Comp4: Comp3, Comp2{
  val str = "hello EnComping"
  
  fork fun foo(){
    base@Comp3.foo()
  }
}

new Comp4().foo() // before foo()
                  // hello EnComping
                  // after foo()
```

### 多函数复刻

如前文所示的选择方式，复刻函数也可以同时选择多个目标组件来拉取函数的变基拷贝：

```ecs
comp Comp5: Comp3, Comp2{
  val str = "hello EnComping"
  
  fork fun foo(){
    base@Comp2.foo()
    base@Comp3.foo()
  }
}

new Comp4().foo() // hello EnComping
                  // before foo()
                  // hello EnComping
                  // after foo()
```

### 复刻是静态解析的

函数复刻是一个静态解析的功能，复刻函数实际上是将复刻的基函数完整的复制到函数体中标记的位置，其中的所有对成员的访问和调用的`this`指针都会自然的被转移到复刻函数体中，复刻函数的组件中并没有某些成员时，也会按照成员的隐藏规则进行向上访问。

因此，对于原型函数的复刻同样会在调用时被正确的通知。
