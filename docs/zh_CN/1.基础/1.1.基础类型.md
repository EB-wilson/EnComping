## 基础类型

基础数据类型指数字，字符，字符串等**简单字面常量**数据，所有的基础类型都属于**字面常量类型（Literal Constant Type）**，在ECP中，基础类型也被定义为了对象。下表列出了ECP当中的所有基础数据类型：

|   类型    | 释义     | 取值范围                         | 示例           |
|:-------:|--------|------------------------------|--------------|
|  Unit   | 空类型占位  | Unit                         | Unit         |
|  Byte   | 8位整数   | -128 ~ 127                   | 123          |
|  Short  | 16位整数  | -32768 ~ 32767               | 12345        |
|   Int   | 32位整数  | -2^31 ~ 2^31-1               | 123456789    |
|  Long   | 64位整数  | -2^63 ~ 2^63-1               | 123456789L   |
|  Float  | 32位浮点数 | ±1.18\*10^-38 ~ ±3.4\*10^38  | 3.1415926F   |
| Double  | 64位浮点数 | ±1.7\*10^-308 ~ ±1.7\*10^308 | 2.7182818    |
| Boolean | 布尔值    | true / false                 | true         |
|  Char   | 单字符    | Any Unicode                  | 'C'          |
| String  | 字符串    | Any String                   | "HelloWorld" |

### 基础类型转换

数字类型之间不可互相赋值，需要进行类型转换，数字类型转换应当使用其作为对象的成员函数。

所有的数字类型都具备如下列出的类型转换函数：

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`
- `nonZero(): Boolean`

其中当浮点型转换为整数型时，会对数字向下取整数，例如`12.86f.toInt()`会得到`12`。 当数据转换为容量更低的数据类型时，数据会被数据上界截断，即当`65536`转换为`Byte`时，数据会被截断到`127`。

数字类型转换为布尔型的默认方法是`nonZero()`提供的非0判断，即在数字为0时为`false`，否则为`true`，这类似于在C语言中直接将数据用作布尔表达式。

`Boolean`具备除`nonZero()`外的转换到所有数字类型的方法，无论转换的目标结果是什么，布尔值转换为数字始终遵循`false -> 0`，`true -> 1`的规则。

特殊的，浮点数据类型`Float`和`Double`具备额外三个函数用于分别进行**向下取整**，**向上取整**和**周围取整**：

- `toCeil(): Int/Long`
- `toFloor(): Int/Long`
- `toRound(boundary: Float/Double): Int/Long`

类型上，对`Float`，上述方法取整的返回结果为`Int`，对`Double`，返回结果则为`Long`。

`Char`和`Int`类型可以相互转换，在`Char`中有`toInt(): Int`函数，返回该字符的Unicode十六进制编码的`Int`；而`Int`内有`toChar(): Char`将数字转换为`Char`，将`Int`的十六进制编码作为字符的Unicode以获得其字符。

### NaN

在ECP中，浮点数类型`Float`和`Double`具备一个特殊的值`NaN`，这表示这不是一个数字，例如`1.0f / 0.0f`的结果为`NaN`，通常`NaN`不应当参与运算，它会带来相当多意外的情况，如：

- `NaN`与任何值都不相等，包括它本身，即`NaN == NaN`为`false`
- `NaN`参与任何运算结果都是`NaN`，即`NaN + 128`仍然为`NaN`
- `NaN`与任何值比较结果都是`false`，即`NaN > 10`为`false`

可通过函数`isNaN(): Boolean`来确定此数字是否为`NaN`。

### 整数类型字面量

`Int`和`Long`的字面量允许分段以及按不同的基数进行编码，`Long`字面量需要在数据末尾附加符号`L`。

默认情况下编码整数字面量的基数为10，可使用`b`或者`x`使整数字面量采用二进制或十六进制编码，以下字面量是等价的：

```ecs
val dec = 171
val bin = 0b10101011
val hex = 0xab
```

可以使用下划线`_`对数据进行分段，可用下划线将数据划分为若干个长度相同的部分，除高位的分块字数允许不足外长度应保持一致且至少为2，如下是几个分段形式：

```ecs
val a = 1_048_576
val b = 0b1100_1011_1100_1011
val x = 0xff_5c_8b_a7
```

以下则是非法的，各块长度应当一致，只有高位的分段允许缺位：

```ecs
val d = 10_68_754_3363L
```
