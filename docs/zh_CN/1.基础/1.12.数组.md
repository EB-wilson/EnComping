## 数组

**数组（Array）** 是一块**容量确定**的可以有序存放一系列特定类型的对象的容器。

数组的类型为被`[]`包裹的类型，形如`[ElementType]`，可多层数组类型嵌套。特别的，数组类型还可以附加长度信息，形如：`[ElementType:length]`，此种形式被成为`定长数组类型`。

```ecs
val arr1: [String]
val arr2: [[[String]]]
val arr3: [[String: 10]: 10]
```

通常可以通过表达式`{elements}`获取一个数组的实例，特别的是，对于元素类型可为空的**定长数组**，可以使用单下划线占位`{_}`来使用空值填充整个数组：

```ecs
val arr4 = {"str1", "str2", "str3"}
val arr5: [Int] = {1, 2, 3, 4, 5}
val arr6: [[Boolean]: 3] = {{true, false}, {false}, {true}}
val arr7: [[Any?: 3]: 3] = {_}
```

但有时候声明处会缺失明确的类型信息，或者数组并非定长数组类型，亦或者需要通过一个初始值函数来生成数组元素，则应采用`new [ElementType:length]{value builder}`的方式来实例化数组，元素类型在已给定时是可选的，此时该语句有数种变体：

```ecs
val arr8 = new [String: 3]{ "unset" }
val arr9: [Boolean] = new [3]{ false }
val arr10: [[Int]] = new [[3]: 3]{ 0 }
val arr10: [[(Int, Int)]] = new [[100]: 100]{ x, y -> (x, y) }
```

特别注意，在上述三个语句中出现的实例化语句右侧的`{...}`块含义与前者字面量的含义完全不同，在此处该块表示了一个匿名函数用于生成数组元素默认值，而非用于字面设定数组元素。

初始值函数当中会有一组与数组的嵌套维数相同个数的`Int`类型的参数，用于确定函数正在填充的数组位置，但是也可以不接收这些参数，直接使用无参数的Lambda块，即将此块的返回值填充到数组的每一个位置。

最后一种`arr6`上的语句与`arr3`功能大致相同。

无论采用`Array<Type>`还是`Type[]`声明数组，二者事实上都是等价的，调用和初始化的语法也都是一致的。

### 读写数组

ECP中数组的下标从`0`开始，即索引`0`对应的是数组的**第一个**元素。要访问和设置数组中的元素，可以使用符号`[index]`索引数组的下标：

```ecs
val arr = {1, 2, 3, 4, 5}

println(arr.length)      // 输出 5

println(arr[0])          // 输出 1
println(arr[2])          // 输出 3
arr[2] = 10              // 将索引为 2 的元素修改为 10
println(arr)             // 输出 [1, 2, 10, 4, 5]
``` 

或者使用与此符号相应的成员函数，尽管这并不被建议使用：

```ecs
val arr = {1, 2, 3, 4, 5}

println(arr.length)      // 输出 5

println(arr.get(0))      // 输出 1
println(arr.get(2))      // 输出 3
arr.set(2, 10)           // 将索引为 2 的元素修改为 10
println(arr)             // 输出 [1, 2, 10, 4, 5]
```

需要注意的是数组的下标范围，**数组下标不可小于0或大于等于其容量**，可以通过对数组访问其只读成员`length`来获取数组的长度，如果输入的索引不属于此范围，则程序会抛出异常`IndexOutOfBoundsException`。

### 多维数组

多维数组是数组的符号声明的一种特殊形式，即数组类型后方有一个以上的`[]`，例如：

```ecs
val a: String[] = new String[10]{ "($it)" }
val b: String[][] = new String[10][10]{ x, y -> "($x, $y)" }
val c: String[][][] = new String[10][10][10]{ x, y, z -> "($x, $y, $z)" }

println(a[3])    // 输出 (3)
println(b[3][4]) // 输出 (3, 4)
println(b[5])    // 输出 [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)]
println(c[2][3]) // 输出 [(2, 3, 0), (2, 3, 1), (2, 3, 2), (2, 3, 3),(2, 3, 4), (2, 3, 5), (2, 3, 6), (2, 3, 7), (2, 3, 8), (2, 3, 9)]
```

上述`a` `b` `c`依次是一维，二维和三维数组，多维数组的初始值函数参数会依次传入在多维数组中各维度上的索引。

多维数组事实上是多个一维数组的嵌套，从高维数组中索引实际上也获取的是一个次一级嵌套的数组，从上文中可以直观的看到。

因此，当采用集合化数组类型时，多维数组又被成为嵌套数组，即：

```
val d: Array<String> = new Array(10, {($it)})
val e: Array<Array<String>> = new Array(10, {x -> new Array(10, {y -> "($x, $y)"})})
val f: Array<Array<Array<String>>> = new Array(10, {x -> new Array(10, {y -> new Array(10, {z -> "($x, $y, $z)"})})})
```

对如上代码的`d` `e` `f`进行访问时，其访问方式与前文当中的多维数组中是完全相同的。不同的是在集合嵌套的初始化语句中，初始值函数需要依次产出每一层嵌套所使用的数组元素，而在多维数组中，则是接收与维数相同个数的参数来逐个产生元素。
